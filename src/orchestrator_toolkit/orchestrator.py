from __future__ import annotations
import argparse, re, subprocess
from pathlib import Path
from typing import Optional, Dict, Any, Tuple
from datetime import datetime
from .settings import OrchSettings
from .utils import now_iso, atomic_write
from .id_alloc import next_numeric
from .archon_adapter import tasks_upsert, events_create
from .ids import spec_id as generate_spec_id
from .owner import resolve_owner
from .hooks import fire_hook

TASK_FRONTMATTER = re.compile(r'^---[\s\S]*?id:\s*(T-\d+)[\s\S]*?title:\s*(.+?)\n[\s\S]*?owner:\s*(.+?)\n[\s\S]*?status:\s*(\w+)[\s\S]*?---', re.MULTILINE)

PLAN_FRONTMATTER = re.compile(
    r'^---\s*\n'
    r'(?:.*\n)*?'
    r'id:\s*([^\n]+)\n'
    r'(?:.*\n)*?'
    r'title:\s*([^\n]+)\n'
    r'(?:.*\n)*?'
    r'owner:\s*([^\n]+)\n'
    r'(?:.*\n)*?'
    r'status:\s*([^\n]+)\n'
    r'(?:.*\n)*?'
    r'spec_id:\s*"?([^"\n]*)"?\n'
    r'(?:.*\n)*?'
    r'---',
    re.MULTILINE
)

PLAN_TEMPLATE = """---
id: {plan_id}
task: {task_id}
title: PLAN for: {task_title}
owner: {owner}
created: {now}
status: draft
---

## Overview
(Scaffolded by orchestrator.)

## Steps
1. Draft approach
2. Identify inputs
3. Produce deliverable

## References
- (add paths / URLs)
"""

SPEC_TEMPLATE = """---
id: {spec_id}
title: {title}
owner: {owner}
plan: {plan_id}
created: {now}
status: draft
design_ok: false
---

# {spec_id}: {title}

## Objective
Implement the specification for: {plan_title}

## Context
- **Plan Reference**: {plan_id}
- **Dependencies**: To be identified during design phase
- **Constraints**: None identified

## Approach

### Technical Design
- To be determined during design phase

### Implementation Steps
1. [ ] Analyze requirements from PLAN
2. [ ] Design technical approach
3. [ ] Implement solution
4. [ ] Test and validate

## Acceptance Criteria
- [ ] All PLAN objectives met
- [ ] Tests passing
- [ ] Documentation updated

## Notes
Auto-generated from {plan_id} by orchestrator_plans()

---
*Generated by Orchestrator Toolkit*
"""

def _next_plan_id(plans_dir: Path) -> str:
    """Get next plan ID using directory-based ID generation."""
    return next_numeric("P", plans_dir)

def _scan_tasks(settings: OrchSettings):
    for p in sorted(settings.tasks_dir.glob("T-*.md")):
        text = p.read_text(encoding="utf-8", errors="ignore")
        m = TASK_FRONTMATTER.search(text)
        if not m:
            continue
        task_id, title, owner, status = m.group(1), m.group(2).strip(), m.group(3).strip(), m.group(4).strip()
        yield p, task_id, title, owner, status

def _post_statusline(msg: str) -> None:
    hook = Path(".claude/hooks/post_to_statusline.sh")
    if hook.exists():
        subprocess.run([str(hook), msg], check=False)

def _parse_plan(plan_path: Path) -> Optional[Dict[str, Any]]:
    """Parse a PLAN file and extract frontmatter."""
    try:
        content = plan_path.read_text(encoding="utf-8")
        match = PLAN_FRONTMATTER.search(content)
        if not match:
            return None

        plan_id, title, owner, status, spec_id_val = match.groups()

        return {
            "id": plan_id.strip(),
            "title": title.strip(),
            "owner": owner.strip(),
            "status": status.strip().lower(),
            "spec_id": spec_id_val.strip() if spec_id_val else "",
            "path": plan_path,
            "content": content
        }
    except Exception:
        return None

def _update_plan_frontmatter(plan: Dict[str, Any], spec_id: str, new_status: str) -> None:
    """Update PLAN frontmatter with spec_id and status atomically."""
    content = plan["content"]

    # Update spec_id field
    if 'spec_id: ""' in content or 'spec_id:' in content:
        content = re.sub(
            r'spec_id:\s*"?[^"\n]*"?',
            f'spec_id: "{spec_id}"',
            content,
            count=1
        )

    # Update status field
    content = re.sub(
        r'status:\s*[^\n]+',
        f'status: {new_status}',
        content,
        count=1
    )

    # Atomic write
    atomic_write(plan["path"], content)

def _log_orchestration(settings: OrchSettings, action: str) -> None:
    """Log orchestration action to exec_logs."""
    today = datetime.now().strftime("%Y%m%d")
    log_file = settings.exec_logs_dir / f"orchestrate-{today}.md"

    # Create/append to log
    timestamp = now_iso()
    log_entry = f"\n{timestamp}: {action}\n"

    if log_file.exists():
        current = log_file.read_text(encoding="utf-8")
        log_file.write_text(current + log_entry, encoding="utf-8")
    else:
        header = f"# Orchestration Log - {today}\n\n"
        log_file.write_text(header + log_entry, encoding="utf-8")

def orchestrator_plans() -> int:
    """
    Orchestrate PLAN â†’ SPEC workflow.

    Scans plans/ for PLANs with:
    - status == "ready"
    - spec_id == ""

    Creates SPECs atomically and updates PLANs.

    Returns:
        Number of SPECs created
    """
    s = OrchSettings.load()

    # Ensure directories exist
    s.plans_dir.mkdir(parents=True, exist_ok=True)
    s.specs_dir.mkdir(parents=True, exist_ok=True)
    s.exec_logs_dir.mkdir(parents=True, exist_ok=True)

    created = 0

    # Scan all PLAN files (resilient discovery with bounded fallback)
    MAX_DISCOVERY_FILES = 500
    all_md_files = list(s.plans_dir.glob("*.md"))

    if len(all_md_files) > MAX_DISCOVERY_FILES:
        _log_orchestration(s, f"Large directory ({len(all_md_files)} files); limiting to standard filenames")
        plans_to_check = sorted(s.plans_dir.glob("PLAN-*.md"))
    else:
        # Include standard + non-standard with status:ready
        standard_plans = list(s.plans_dir.glob("PLAN-*.md"))
        non_standard = [p for p in all_md_files if not p.name.startswith("PLAN-")]

        plans_to_check = sorted(standard_plans)
        for ns_path in sorted(non_standard):
            ns_plan = _parse_plan(ns_path)
            if ns_plan and ns_plan["status"] == "ready":
                _log_orchestration(s, f"Including non-standard PLAN filename: {ns_path.name}")
                plans_to_check.append(ns_path)

    for plan_path in plans_to_check:
        plan = _parse_plan(plan_path)
        if not plan:
            continue

        # Check if ready for SPEC creation
        if plan["status"] != "ready" or plan["spec_id"]:
            continue

        # Generate SPEC ID
        spec_title = f"Implementation for {plan['title']}"
        new_spec_id = generate_spec_id(spec_title)

        # Create SPEC file (atomic write first)
        spec_path = s.specs_dir / f"{new_spec_id}.md"
        spec_content = SPEC_TEMPLATE.format(
            spec_id=new_spec_id,
            title=spec_title,
            owner=plan["owner"],
            plan_id=plan["id"],
            plan_title=plan["title"],
            now=now_iso()
        )

        # Write SPEC first (atomic)
        atomic_write(spec_path, spec_content)

        # Update PLAN with spec_id (atomic)
        _update_plan_frontmatter(plan, new_spec_id, "in-spec")

        # Fire hooks (non-blocking)
        try:
            fire_hook(
                artifact_type="spec",
                artifact_id=new_spec_id,
                old_status=None,
                new_status="draft"
            )
        except Exception:
            pass  # Non-blocking

        # Log action
        _log_orchestration(s, f"Created {new_spec_id} from {plan['id']}")

        # Update statusline
        _post_statusline(f"Created SPEC: {spec_path}")

        created += 1
        print(f"Created: {spec_path}")

    # TODO: Implementation Gate
    # When implementation phase is built, enforce design_ok gate:
    # for spec_path in s.specs_dir.glob("SPEC-*.md"):
    #     spec = _parse_spec(spec_path)
    #     if spec and spec["design_ok"] is True:
    #         proceed_to_implementation(spec)
    #     else:
    #         log(f"SPEC {spec['id']} not design_ok:true; implementation gated")

    return created

def once() -> int:
    s = OrchSettings.load()  # Use centralized loader

    created = 0
    for path, task_id, title, owner, status in _scan_tasks(s):
        if status.lower() != "assigned":
            continue

        plan_id_num = _next_plan_id(s.plans_dir)
        plan_id = f"P-{plan_id_num}"
        plan_path = s.plans_dir / f"{plan_id}.md"
        atomic_write(plan_path, PLAN_TEMPLATE.format(
            plan_id=plan_id,
            task_id=task_id,
            task_title=title,
            owner=owner,
            now=now_iso()
        ))
        created += 1

        # Inform Archon (best-effort) and statusline
        tasks_upsert(s, {"id": task_id, "title": title, "owner": owner, "status": "assigned"})
        events_create(s, "log", f"Scaffolded {plan_id} for {task_id}", {"plan": str(plan_path)})
        _post_statusline(f"Next step: open {plan_path} (scaffolded for {task_id})")

    return created

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--watch", action="store_true", help="poll every 5s")
    args = ap.parse_args()
    if not args.watch:
        c = once()
        print(f"created_plans={c}")
    else:
        import time
        while True:
            c = once()
            if c:
                print(f"created_plans={c}")
            time.sleep(5)

if __name__ == "__main__":
    main()
